<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Online Piano</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(180deg, #000000, #ffffff);
      margin: 0;
      font-family: 'Inter', system-ui, -apple-system, sans-serif;
      color: #fff;
      user-select: none;
      overflow: hidden;
    }
    .controls {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 1.5rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
      width: 100%;
      max-width: 840px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      margin: 4rem;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .control-group label {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.9;
    }
    select, button {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.75rem 1rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s ease;
    }
    select:hover, button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    input[type="range"] {
      width: 100%;
      height: 6px;
      appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      background: #fff;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }
    .piano {
      position: relative;
      width: 100%;
      max-width: 840px;
      height: 280px;
      background: rgba(255, 255, 255, 0.1);
      padding: 1.5rem;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }
    .white-keys {
      display: flex;
      height: 100%;
    }
    .key.white {
      flex: 1;
      height: 100%;
      background: linear-gradient(to bottom, #fff 0%, #f0f0f0 100%);
      border: 1px solid #000;
      box-sizing: border-box;
      border-radius: 0 0 5px 5px;
      transition: all 0.1s ease;
      z-index: 1;
      cursor: pointer;
      position: relative;
    }
    .key.white:hover {
      background: linear-gradient(to bottom, #f0f0f0 0%, #e6e6e6 100%);
    }
    .black-keys {
      position: absolute;
      top: 1.5rem;
      left: 0;
      right: 0;
      height: 160px;
      pointer-events: none;
    }
    .key.black {
      position: absolute;
      background: linear-gradient(to bottom, #000 0%, #222 100%);
      border: 1px solid #000;
      border-radius: 0 0 3px 3px;
      transition: all 0.1s ease;
      z-index: 2;
      cursor: pointer;
      pointer-events: auto;
    }
    .key.black:hover {
      background: linear-gradient(to bottom, #222 0%, #333 100%);
    }
    .key.active {
      transform: translateY(4px);
      box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.3);
    }
    .key.white.active {
      background: linear-gradient(to bottom, #e6e6e6 0%, #d9d9d9 100%);
    }
    .key.black.active {
      background: linear-gradient(to bottom, #111 0%, #222 100%);
    }
    .key-label {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: #666;
      pointer-events: none;
    }
    .black .key-label {
      color: #fff;
      bottom: 20px;
    }
    .visualizer {
      width: 100%;
      max-width: 840px;
      height: 100px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      margin-top: 20px;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <div class="controls">
    <div class="control-group">
      <label>Waveform:</label>
      <select id="waveform">
        <option value="sine">Sine</option>
        <option value="square">Square</option>
        <option value="sawtooth">Sawtooth</option>
        <option value="triangle">Triangle</option>
      </select>
    </div>
    <div class="control-group">
      <label>Reverb:</label>
      <select id="reverb">
        <option value="0">None</option>
        <option value="0.1">Small Room</option>
        <option value="0.2">Medium Room</option>
        <option value="0.3">Large Hall</option>
      </select>
    </div>
    <div class="control-group">
      <label>Volume:</label>
      <input type="range" id="volume" min="0" max="100" value="70">
    </div>
    <div class="control-group">
      <label>Detune (cents):</label>
      <input type="range" id="detune" min="-50" max="50" value="0">
    </div>
  </div>
  <div class="piano">
    <div class="white-keys">
      <div class="key white" data-note="C" data-key="a"><div class="key-label">A</div></div>
      <div class="key white" data-note="D" data-key="s"><div class="key-label">S</div></div>
      <div class="key white" data-note="E" data-key="d"><div class="key-label">D</div></div>
      <div class="key white" data-note="F" data-key="f"><div class="key-label">F</div></div>
      <div class="key white" data-note="G" data-key="g"><div class="key-label">G</div></div>
      <div class="key white" data-note="A" data-key="h"><div class="key-label">H</div></div>
      <div class="key white" data-note="B" data-key="j"><div class="key-label">J</div></div>
      <div class="key white" data-note="C2" data-key="k"><div class="key-label">K</div></div>
      <div class="key white" data-note="D2" data-key="l"><div class="key-label">L</div></div>
      <div class="key white" data-note="E2" data-key=";"><div class="key-label">;</div></div>
      <div class="key white" data-note="F2" data-key="'"><div class="key-label">'</div></div>
    </div>
    <div class="black-keys">
      <div class="key black" data-note="C#" data-key="w" data-pos="0"><div class="key-label">W</div></div>
      <div class="key black" data-note="D#" data-key="e" data-pos="1"><div class="key-label">E</div></div>
      <div class="key black" data-note="F#" data-key="t" data-pos="3"><div class="key-label">T</div></div>
      <div class="key black" data-note="G#" data-key="y" data-pos="4"><div class="key-label">Y</div></div>
      <div class="key black" data-note="A#" data-key="u" data-pos="5"><div class="key-label">U</div></div>
      <div class="key black" data-note="C#2" data-key="o" data-pos="7"><div class="key-label">O</div></div>
      <div class="key black" data-note="D#2" data-key="p" data-pos="8"><div class="key-label">P</div></div>
    </div>
  </div>
  <canvas class="visualizer"></canvas>
  <script>
    const notes = {
      'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13, 'E': 329.63,
      'F': 349.23, 'F#': 369.99, 'G': 392.00, 'G#': 415.30, 'A': 440.00,
      'A#': 466.16, 'B': 493.88, 'C2': 523.25, 'C#2': 554.37, 'D2': 587.33,
      'D#2': 622.25, 'E2': 659.26, 'F2': 698.46
    };
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const masterGain = audioCtx.createGain();
    const convolver = audioCtx.createConvolver();
    const analyzer = audioCtx.createAnalyser();
    const compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -15;
    compressor.knee.value = 10;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.005;
    compressor.release.value = 0.1;
    masterGain.connect(compressor);
    compressor.connect(analyzer);
    analyzer.connect(audioCtx.destination);
    const canvas = document.querySelector('.visualizer');
    const canvasCtx = canvas.getContext('2d');
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    analyzer.fftSize = 2048;
    const bufferLength = analyzer.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);
    function updatePolyphonicGain() {
      const activeCount = Object.keys(activeNotes).length;
      if (activeCount > 0) {
        const reduction = Math.max(0.2, 1 / Math.sqrt(activeCount));
        const volume = (document.getElementById('volume').value / 100) * reduction;
        Object.values(activeNotes).forEach(({ gainNode }) => {
          gainNode.gain.setTargetAtTime(volume, audioCtx.currentTime, 0.01);
        });
      }
    }
    function drawVisualizer() {
      requestAnimationFrame(drawVisualizer);
      analyzer.getFloatTimeDomainData(dataArray);
      canvasCtx.fillStyle = 'rgb(26, 26, 26)';
      canvasCtx.fillRect(0, 0, canvas.width, canvas.height);
      canvasCtx.lineWidth = 2;
      canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
      canvasCtx.beginPath();
      const sliceWidth = canvas.width / bufferLength;
      let x = 0;
      for (let i = 0; i < bufferLength; i++) {
        const v = dataArray[i] * 90.0;
        const y = (canvas.height / 2) + (v * canvas.height / 2);
        if (i === 0) {
          canvasCtx.moveTo(x, y);
        } else {
          canvasCtx.lineTo(x, y);
        }
        x += sliceWidth;
      }
      canvasCtx.lineTo(canvas.width, canvas.height / 2);
      canvasCtx.stroke();
    }
    drawVisualizer();
    function createImpulseResponse(duration, decay) {
      const sampleRate = audioCtx.sampleRate;
      const length = sampleRate * duration;
      const impulse = audioCtx.createBuffer(2, length, sampleRate);
      const left = impulse.getChannelData(0);
      const right = impulse.getChannelData(1);
      for (let i = 0; i < length; i++) {
        const n = i / length;
        left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
        right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
      }
      return impulse;
    }
    document.getElementById('reverb').addEventListener('change', (e) => {
      const reverbTime = parseFloat(e.target.value);
      if (reverbTime === 0) {
        masterGain.disconnect();
        masterGain.connect(analyzer);
      } else {
        convolver.buffer = createImpulseResponse(reverbTime, 2);
        masterGain.disconnect();
        masterGain.connect(convolver);
        convolver.connect(analyzer);
      }
    });
    let shiftUpPressed = false;
    let shiftDownPressed = false;
    function getShiftFactor() {
      if (shiftUpPressed && !shiftDownPressed) {
        return Math.pow(2, 2/12);
      } else if (shiftDownPressed && !shiftUpPressed) {
        return Math.pow(2, -2/12);
      }
      return 1;
    }
    const activeNotes = {};
    function startNote(keyElement) {
      const keyId = keyElement.dataset.key;
      if (activeNotes[keyId]) return;
      const noteName = keyElement.dataset.note;
      const baseFrequency = notes[noteName];
      if (!baseFrequency) return;
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();
      oscillator.type = document.getElementById('waveform').value;
      oscillator.detune.value = parseFloat(document.getElementById('detune').value);
      const shiftFactor = getShiftFactor();
      oscillator.frequency.value = baseFrequency * shiftFactor;
      gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
      oscillator.connect(gainNode);
      gainNode.connect(masterGain);
      oscillator.start();
      activeNotes[keyId] = { oscillator, gainNode, baseFrequency, keyElement };
      updatePolyphonicGain();
    }
    function stopNote(keyElement) {
      const keyId = keyElement.dataset.key;
      const noteData = activeNotes[keyId];
      if (!noteData) return;
      const { oscillator, gainNode } = noteData;
      gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
      gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
      oscillator.stop(audioCtx.currentTime + 0.1);
      delete activeNotes[keyId];
      updatePolyphonicGain();
    }
    function updateActiveOscillatorFrequencies() {
      const shiftFactor = getShiftFactor();
      const slideTime = 0.1;
      for (const keyId in activeNotes) {
        const { oscillator, baseFrequency } = activeNotes[keyId];
        const newFreq = baseFrequency * shiftFactor;
        oscillator.frequency.cancelScheduledValues(audioCtx.currentTime);
        oscillator.frequency.linearRampToValueAtTime(newFreq, audioCtx.currentTime + slideTime);
      }
    }
    document.querySelectorAll('.key').forEach(key => {
      ['mousedown', 'touchstart'].forEach(eventName => {
        key.addEventListener(eventName, (e) => {
          e.preventDefault();
          if (audioCtx.state === 'suspended') {
            audioCtx.resume();
          }
          startNote(key);
          key.classList.add('active');
        });
      });
      ['mouseup', 'mouseleave', 'touchend'].forEach(eventName => {
        key.addEventListener(eventName, () => {
          key.classList.remove('active');
          stopNote(key);
        });
      });
    });
    document.addEventListener('keydown', e => {
      if (e.repeat) return;
      if (e.key === '1') {
        shiftDownPressed = true;
        updateActiveOscillatorFrequencies();
        return;
      }
      if (e.key === '2') {
        shiftUpPressed = true;
        updateActiveOscillatorFrequencies();
        return;
      }
      const keyElement = document.querySelector(`.key[data-key="${e.key}"]`);
      if (keyElement) {
        if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
        startNote(keyElement);
        keyElement.classList.add('active');
      }
    });
    document.addEventListener('keyup', e => {
      if (e.key === '1') {
        shiftDownPressed = false;
        updateActiveOscillatorFrequencies();
        return;
      }
      if (e.key === '2') {
        shiftUpPressed = false;
        updateActiveOscillatorFrequencies();
        return;
      }
      const keyElement = document.querySelector(`.key[data-key="${e.key}"]`);
      if (keyElement) {
        keyElement.classList.remove('active');
        stopNote(keyElement);
      }
    });
    function updateBlackKeys() {
      const piano = document.querySelector('.piano');
      const pianoRect = piano.getBoundingClientRect();
      const whiteKeys = piano.querySelectorAll('.white-keys .key.white');
      const whiteKeyPositions = Array.from(whiteKeys).map(key => {
        const rect = key.getBoundingClientRect();
        return { left: rect.left - pianoRect.left, width: rect.width };
      });
      const blackKeys = piano.querySelectorAll('.black-keys .key.black');
      blackKeys.forEach(key => {
        const posIndex = parseInt(key.dataset.pos, 10);
        if (!isNaN(posIndex) && whiteKeyPositions[posIndex]) {
          const whiteKey = whiteKeyPositions[posIndex];
          const blackWidth = whiteKey.width * (40 / 60);
          const left = whiteKey.left + whiteKey.width - (blackWidth / 2);
          key.style.width = `${blackWidth}px`;
          const blackHeight = pianoRect.height * (160 / 280);
          key.style.height = `${blackHeight}px`;
          key.style.left = `${left}px`;
        }
      });
    }
    window.addEventListener('resize', updateBlackKeys);
    window.addEventListener('DOMContentLoaded', updateBlackKeys);
  </script>
</body>
</html>